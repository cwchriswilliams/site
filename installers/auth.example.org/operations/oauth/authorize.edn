{:install
 {:juxt.site/subject-id "https://auth.example.org/_site/subjects/system"
  :juxt.site/operation-id "https://auth.example.org/_site/operations/create-operation"
  :juxt.site/input
  {:xt/id "{{$id}}"

   ;; Eventually we should look up if there's evidence of the
   ;; resource-owner's consent in place to cover the application and
   ;; scopes requested.  The consent should include details of what
   ;; scope was requested by the application, and what scope was
   ;; approved by the resource-owner (which may be the same). If
   ;; additional scope is requested in a subsequent authorization
   ;; request, then updated consent will then be sought from the
   ;; resource-owner.
   ;;
   ;; If we can't find the consent, we create a new pending consent
   ;; document containing the state, application and scope. We
   ;; redirect to a trusted resource, within the same protection space
   ;; or session scope, e.g. /approve. This is given the id of a
   ;; pending approval as a request parameter, from which it can look
   ;; up the pending approval document and render the form
   ;; appropriately given the attributes therein.
   ;;

   :juxt.site/prepare
   {:juxt.site.sci/program
    #juxt.pprint
    (let [qs (:ring.request/query *ctx*)
          _ (when-not qs
              (throw
               (ex-info
                "No query string, client_id and response_type query parameters are required"
                {:ring.response/status 400})))

          query (ring.util.codec/form-decode qs)

          client-id (get query "client_id")
          _ (when-not client-id
              (throw
               (ex-info "A client_id parameter is required" {:ring.response/status 400})))

          response-type (get query "response_type")
          _ (when-not response-type
              (throw
               (ex-info
                "A response_type parameter is required"
                {"error" "invalid_request"})))

          _ (when (sequential? response-type)
              (throw
               (ex-info
                "The response_type parameter must only be provided once"
                {"error" "invalid_request"})))

          _ (when-not (contains? #{"code" "token"} response-type)
              (throw (ex-info "Only response types of 'code' and 'token' are currently supported" {})))

          subject (:juxt.site/subject *ctx*)
          _ (when-not subject
              (throw (ex-info "Cannot create access-token: no subject" {})))

          ;; "The authorization server SHOULD document the size of any
          ;; value it issues." -- RFC 6749 Section 4.2.2
          jti-length 16

          code-length 8]

      (cond-> {:response-type response-type
               :client-id client-id
               :query query
               :subject (:xt/id subject)}

        (= response-type "code")
        (into {:code (juxt.site.util/make-nonce code-length)})

        (= response-type "token")
        (into {:jwt-claims {"iss" "https://auth.example.org"
                            "jti" (juxt.site.util/make-nonce jti-length)}})))}

   :juxt.site/transact
   {:juxt.site.sci/program
    #juxt.pprint
    (let [{:keys [response-type client-id subject query]} *prepare*
          application (juxt.site/lookup-client client-id)
          _ (when-not application
              (throw
               (ex-info
                (format "No client found with client-id of %s" client-id)
                {:client-id client-id})))]

      (case response-type

        "code"
        (let [{:keys [code]} *prepare*

              scopes nil

              code-challenge (get query "code_challenge")
              code-challenge-method (get query "code_challenge_method")

              code-doc
              (cond->
                  {:xt/id (str "https://auth.example.org/authorization-codes/" code)
                   :juxt.site/type "https://meta.juxt.site/types/authorization-code"
                   :juxt.site/subject subject
                   :juxt.site/application (:xt/id application)
                   :juxt.site/code code}
                  code-challenge (assoc :juxt.site/code-challenge code-challenge)
                  code-challenge-method (assoc :juxt.site/code-challenge-method code-challenge-method)
                  scopes (assoc :juxt.site/scope scopes))

              query-component
              (ring.util.codec/form-encode
               {"code" code
                "state" (get query "state")})

              location (format "%s?%s" (:juxt.site/redirect-uri application) query-component)]

          [[:xtdb.api/put code-doc]
           [:ring.response/status 303]
           [:ring.response/headers {"location" location}]])

        "token" ;; implicit
        (let [{:keys [jwt-claims]} *prepare*

              ;; Leave scope for now for tests to flush out
              ;; scopes (some-> *prepare* (get-in [:query "scope"]) ring.util.codec/form-decode (clojure.string/split (re-pattern "\\s")) set)
              ;;_ (doall (map juxt.site/lookup-scope scopes))

              scopes nil

              client (juxt.site/lookup-client client-id)

              jwt-id (get jwt-claims "jti")

              resource-server (:juxt.site/resource-server client)

              access-token
              (juxt.site/make-access-token
               (cond-> jwt-claims
                 resource-server (assoc "aud" resource-server)
                 true (merge
                       {"iat" (java.util.Date.)
                        "nbf" (let [now (.toInstant (java.util.Date.))
                                    expiry (.minus now 2 java.time.temporal.ChronoUnit/MINUTES)]
                                (java.util.Date/from expiry))
                        "exp" (let [now (.toInstant (java.util.Date.))
                                    expiry (.plus now 15 java.time.temporal.ChronoUnit/MINUTES)]
                                (java.util.Date/from expiry))}))
               (:juxt.site/signing-keypair *resource*))

              access-token-doc
              (cond->
                  {:xt/id (str "https://auth.example.org/access-tokens/" jwt-id)
                   :juxt.site/type "https://meta.juxt.site/types/access-token"
                   :juxt.site/subject subject
                   :juxt.site/application (:xt/id application)
                   :juxt.site/token access-token}
                  scopes (assoc :juxt.site/scope scopes))

              fragment
              (ring.util.codec/form-encode
               {"access_token" access-token
                "token_type" "bearer"
                "state" (get query "state")})

              location (format "%s#%s" (:juxt.site/redirect-uri application) fragment)]

          [[:xtdb.api/put access-token-doc]
           [:ring.response/status 303]
           [:ring.response/headers {"location" location}]])))}

   :juxt.site/rules
   [
    [(allowed? subject operation resource permission)
     [subject :juxt.site/user-identity id]
     [id :juxt.site/user user]
     [permission :juxt.site/user user]]]}}}
